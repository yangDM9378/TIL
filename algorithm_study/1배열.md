# 배열
## 배열이란 무엇인가?
- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

## 2차원 배열
### 배열 순회
- 행우선 순회
```python
for i in range(n): # i는 행좌표
  for j in range(m): # j는 열좌표
    arr[i][j] # 필요연산 수행
```
- 열우선 순회
```python
for j in range(m): # j는 열좌표
  for i in range(n): # i는 행좌표
    arr[i][j] # 필요연산 수행
```
- 지그재그 순회
```python
for i in range(n): # j는 열좌표
  for j in range(m): # i는 행좌표
    arr[i][j+(m-1-2*j)*(i%2)] # 필요연산 수행
```
-------------------------------
# 정렬
## 정렬이란?
- 두개 이상의 자료를 특정 기준에 의해 작은 값부터 큰값 혹은, 반대로 재배열하는 것
## 정렬 방식의 종류
- 버블정렬(Bubble Sort)
- 카운팅정렬(Counting Sort)
- 선택정렬(Selection Sort)
- 퀵정렬(Quick Sort)
- 삽입정렬(Insertion Sort)
- 병합정렬(Merge Sort)
## - 버블 정렬(Bubble Sort)
### 버블 정렬
- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
### 정렬 과정
- 첫 번째 원소부터 인접한 원소끼리 자리를 교환하면서 맨 마지막 자리까지 이동
- 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬
### 시간복잡도
- O(n^2)

```python
def BubbleSort(a,N): #정렬할 List N원소수
  for y in range(N-1,0,-1): #범위의 끝 위치
    for x in range(0,i):
      if a[j]>a[j+1]:
        a[j], a[j+1]=a[j+1], a[j]
```

## - 카운팅 정렬(Counting Sort)
### 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하며, 선형 시간에 정렬하는 효율적인 알고리즘
### 제한 사항
- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용가능 : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알고 있어야함
### 시간복잡도
O(n+k):n은 리스트 길이,k는 정수 최대값
### 정렬과정
1. 각 항목들의 발생 회수를 세고, 정수 항목들로 카운트 배열에 저장한다.
2. 각 항목 앞에 위치할 개수를 반영하기 위해 카운트 배열의 누적합을 구한다.
3. 카운트 배열을 1감소시키고 새로운 배열의 카운트 수의 위치에 정수를 입력한다.
```python
def counting_sort(a,n):
  bucket=[0]*101
  # 1. 항목의 발생횟수를 세고 카운트 배열 생성
  for i in range(n):
      bucket[a[i]]+=1
  # 2.누적합 구하기
  for i in range(1,len(bucket)):
      bucket[i]+=bucket[i-1]
  # 3. 값넣기
  result=[0]*101
  for i in range(n-1,-1,-1): #거꾸로 돌려줘야 순서에 맞게됨
      index=a[i]
      result[bucket[index]-1]=a[i]
      bucket[index]-=1
```

## - 선택 정렬(Selection Sort)
### 선택 정렬
- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
### 정렬과정
- 주어진 리스트 중 최소값 찾기
- 값을 맨 앞의 값과 교환
- 처음을 제외한 리스트 대상으로 과정 반복
### 시간복잡도
- O(n^2)
``` python
def Selection_Sort(arr):
  for y in range(len(arr)-1):
    minIdx=i
    for x in range((y+1),len(arr)):
      if arr[minIdx]>arr[x]:
        minIdx=j
      arr[i],arr[minIdx]=arr[minIdx],arr[i]:
```

---------------------------------------
# 검색
## 검색
- 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
- 목적하는 탐색 키를 가진 항목을 찾는 것
  - 탐색키(search key): 자료를 구별하여 인식할 수 있는 키
- 검색의 종류
  - 순차 검색(sequential search)
  - 이진 검색(binary search)
  - 해쉬(hash)
## - 순차 검색(Sequential Search)
### 순차 검색
- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
  - 가장 간단하고 직관적
  - 배열이나 연결리스트 등 순차구조로 구현된 자료구조에서 유용
  - 검색 대상이 많은 경우 수행시간이 급격히 증가하여 비효율적
### 2가지 경우
  - 정렬되어 있지 않은 경우
  - 정렬되어 있는 경우
## 정렬되어 있지 않은 경우
### 검색 과정
- 첫 원소부터 순서대로 검색 대상과 값이 같은 원소 비교
- 동일 원소 검색시 인덱스 반환
- 마지막까지 못찾으면 검색 실패
### 시간 복잡도 : O(n)
## 정렬되어 있는 경우
### 검색 과정
- 자료가 오름/내림 차순으로 정렬 된 경우
- 순차적으로 키값을 비교하다가 검색 대상의 값이나 큰/작은 값을 만났을때 없는 것으로 검색 종료
### 검색 실패를 반환하는 경우 평균 횟수가 반으로 감소
### 시간 복잡도 : O(n)
## - 이진 검색(Binary Search)
### 이진 검색
- 자료의 가운데에 있는 항목의 값과 비교하여 다음 검색 위치 결정하여 검색을 진행하는 방법
  - 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 빠르게 검색
- 이진 검색을 하기 위해서는 자료가 정렬된 상태
### 검색 과정
- 자료의 중앙 원소 고르기
- 중앙 원소의 값과 목표값 비교
- 목표값이 중앙 원소보다 작으면 왼쪽에 대해 검색 수행, 크면 오른쪽에 대해 검색 수행
- 값을 찾을때까지 반복
### 구현
- 검색 범위의 시작과 종료점을 이용하여 검색 반복 수행
- 이진 검색의 경우, 삽입이나 삭제가 발생했을 때 배열의 상태를 정렬 상태로 유지하는 추가 작업 필요
``` python
def binary_search(s,e,value):
    while (1):
        m=(s+e)//2
        if arr[m]>value:
            e=m-1
        elif arr[m]<value:
            s=m+1
        else:
            return 1 # 1일때 존재
        if s>e:
            return 0 # 0일때 없음
```